#!/usr/bin/env python3
"""
Telegram Bot with AWS Bedrock Integration and Kiro CLI

Supports two modes:
- /chat: Send prompts to Bedrock (default)
- /code: Send prompts to Kiro CLI
- /help: Show available commands

Requires: TELEGRAM_API_KEY, TELEGRAM_CHAT_ID
Optional:  AWS_REGION, KIRO_OUTPUT_DIR, S3_BUCKET_NAME, S3_PREFIX,
           CLOUDFRONT_BASE_URL
"""

import json
import os
import re
import subprocess
import sys
import time
from pathlib import Path

import boto3
import requests

try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass  # python-dotenv is optional; env vars can be set externally

# Path to the Kiro steering file that tells Kiro where to save outputs
KIRO_STEERING_FILE = Path(__file__).parent / ".kiro" / "steering" / "output-config.md"


# ---------------------------------------------------------------------------
# Configuration
# ---------------------------------------------------------------------------

def get_config():
    api_key = os.environ.get('TELEGRAM_API_KEY')
    chat_id = os.environ.get('TELEGRAM_CHAT_ID')
    region = os.environ.get('AWS_REGION', 'us-west-2')
    kiro_output_dir = os.environ.get('KIRO_OUTPUT_DIR', '').strip()
    cloudfront_base_url = os.environ.get('CLOUDFRONT_BASE_URL', '').rstrip('/')
    s3_prefix = os.environ.get('S3_PREFIX', '').strip('/')

    if not api_key or not chat_id:
        print("Error: TELEGRAM_API_KEY and TELEGRAM_CHAT_ID must be set")
        sys.exit(1)

    return api_key, chat_id, region, kiro_output_dir, cloudfront_base_url, s3_prefix


# ---------------------------------------------------------------------------
# Kiro output directory and context file
# ---------------------------------------------------------------------------

def ensure_output_dir(kiro_output_dir):
    """Create the Kiro output directory if it does not exist."""
    if not kiro_output_dir:
        return
    path = Path(kiro_output_dir)
    path.mkdir(parents=True, exist_ok=True)
    print(f"Kiro output directory: {path.resolve()}")


def generate_kiro_context(kiro_output_dir):
    """Write (or overwrite) the Kiro steering file with the current output path.

    The file lives at .kiro/steering/output-config.md and is automatically
    picked up by Kiro CLI on every invocation so it always knows where to
    save generated files.
    """
    if not kiro_output_dir:
        return

    KIRO_STEERING_FILE.parent.mkdir(parents=True, exist_ok=True)
    content = f"""# Kiro CLI Output Configuration

> **Note:** This file is automatically regenerated by `telegram_bot.py` on
> every startup from the `KIRO_OUTPUT_DIR` environment variable. Manual edits
> will be overwritten. To change the output directory, update `KIRO_OUTPUT_DIR`
> in your `.env` file and restart the bot.

## File Output Location

When saving files, outputs, reports, code, or any other generated content,
**always save them to the configured output directory** shown below.

**Output Directory:** `{kiro_output_dir}`

## Naming Conventions

- Use lowercase filenames with hyphens as word separators (e.g., `my-report.html`)
- Include a date suffix for time-sensitive outputs (e.g., `summary-2024-01-15.md`)
- Use the appropriate file extension for the content type

## Guidelines

- Save all generated HTML, Markdown, JSON, CSV, and other output files to the
  output directory above.
- Create subdirectories within the output directory when organising related files
  (e.g., `images/`, `data/`, `reports/`).
- Do **not** save temporary or intermediate working files to the output directory.
- After completing a task, confirm which files were saved and their filenames so
  the bot can report the correct URLs.
"""
    KIRO_STEERING_FILE.write_text(content, encoding="utf-8")
    print(f"Kiro context file updated: {KIRO_STEERING_FILE}")


# ---------------------------------------------------------------------------
# File detection helpers
# ---------------------------------------------------------------------------

def snapshot_dir(directory):
    """Return a dict mapping file paths to their modification times."""
    result = {}
    if not directory:
        return result
    base = Path(directory)
    if not base.exists():
        return result
    for f in base.rglob("*"):
        if f.is_file():
            try:
                result[str(f)] = f.stat().st_mtime
            except OSError:
                pass
    return result


def new_files_since(before, after):
    """Return paths that are new or have been modified between two snapshots."""
    changed = []
    for path, mtime in after.items():
        if path not in before or before[path] != mtime:
            changed.append(path)
    return changed


def build_url(file_path, kiro_output_dir, cloudfront_base_url, s3_prefix):
    """Build the CloudFront URL for a file that lives inside kiro_output_dir."""
    if not cloudfront_base_url:
        return None
    try:
        rel = Path(file_path).relative_to(kiro_output_dir)
    except ValueError:
        return None
    parts = [cloudfront_base_url]
    if s3_prefix:
        parts.append(s3_prefix)
    parts.append(str(rel))
    return "/".join(parts)


# ---------------------------------------------------------------------------
# Telegram helpers
# ---------------------------------------------------------------------------

def strip_ansi(text):
    return re.sub(r'\x1b\[[0-9;]*m', '', text)


def send_message(api_key, chat_id, text):
    try:
        requests.post(
            f"https://api.telegram.org/bot{api_key}/sendMessage",
            json={"chat_id": chat_id, "text": strip_ansi(text)},
            timeout=10
        )
    except Exception as e:
        print(f"Failed to send message: {e}")


# ---------------------------------------------------------------------------
# Backend invocations
# ---------------------------------------------------------------------------

def invoke_bedrock(bedrock, prompt):
    try:
        response = bedrock.invoke_model(
            modelId="global.anthropic.claude-sonnet-4-5-20250929-v1:0",
            body=json.dumps({
                "anthropic_version": "bedrock-2023-05-31",
                "max_tokens": 4096,
                "messages": [{"role": "user", "content": prompt}]
            })
        )
        result = json.loads(response['body'].read())
        return result['content'][0]['text']
    except Exception as e:
        return f"Error: {e}"


def invoke_kiro(prompt, kiro_output_dir, cloudfront_base_url, s3_prefix):
    """Run kiro-cli and detect any files it creates in kiro_output_dir.

    Returns (output_text, list_of_(filename, url) tuples).
    """
    before = snapshot_dir(kiro_output_dir)

    try:
        result = subprocess.run(
            ["kiro-cli", "chat", "--no-interactive", prompt],
            capture_output=True,
            text=True,
            timeout=300
        )
        output = result.stdout if result.stdout else result.stderr
    except Exception as e:
        return f"Error: {e}", []

    after = snapshot_dir(kiro_output_dir)
    changed = new_files_since(before, after)

    urls = []
    if cloudfront_base_url and changed:
        for file_path in sorted(changed):
            url = build_url(file_path, kiro_output_dir, cloudfront_base_url, s3_prefix)
            if url:
                urls.append((Path(file_path).name, url))

    return output, urls


# ---------------------------------------------------------------------------
# Main loop
# ---------------------------------------------------------------------------

def main():
    api_key, chat_id, region, kiro_output_dir, cloudfront_base_url, s3_prefix = get_config()

    # Ensure output directory exists and update Kiro's steering file
    ensure_output_dir(kiro_output_dir)
    generate_kiro_context(kiro_output_dir)

    bedrock = boto3.client('bedrock-runtime', region_name=region)
    offset = 0
    mode = "chat"

    print(f"Bot started. Monitoring chat {chat_id}")

    while True:
        try:
            response = requests.get(
                f"https://api.telegram.org/bot{api_key}/getUpdates",
                params={"offset": offset, "timeout": 30},
                timeout=35
            )
            data = response.json()

            if data.get("ok") and data.get("result"):
                for update in data["result"]:
                    offset = update["update_id"] + 1

                    if "message" in update and "text" in update["message"]:
                        user_text = update["message"]["text"]
                        print(f"Received: {user_text}")

                        if user_text == "/chat":
                            mode = "chat"
                            reply = "Switched to chat mode (Bedrock)"
                            send_message(api_key, chat_id, reply)

                        elif user_text == "/code":
                            mode = "code"
                            reply = "Switched to code mode (Kiro CLI)"
                            send_message(api_key, chat_id, reply)

                        elif user_text == "/help":
                            reply = (
                                "Available commands:\n"
                                "/chat - Switch to Bedrock chat mode\n"
                                "/code - Switch to Kiro CLI mode\n"
                                "/help - Show this help message"
                            )
                            send_message(api_key, chat_id, reply)

                        else:
                            if mode == "chat":
                                reply = invoke_bedrock(bedrock, user_text)
                                send_message(api_key, chat_id, reply)
                            else:
                                reply, new_files = invoke_kiro(
                                    user_text,
                                    kiro_output_dir,
                                    cloudfront_base_url,
                                    s3_prefix,
                                )
                                send_message(api_key, chat_id, reply)

                                if new_files:
                                    lines = ["Files created by Kiro:"]
                                    for filename, url in new_files:
                                        lines.append(f"  {filename}: {url}")
                                    send_message(api_key, chat_id, "\n".join(lines))

                        print(f"Sent reply ({mode} mode)")

        except Exception as e:
            print(f"Error: {e}")
            time.sleep(5)


if __name__ == "__main__":
    main()
